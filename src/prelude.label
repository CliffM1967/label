
    
    [ Here is where we bootstrap our little language]
    [ It is clear that this is a comment, and it is polluting the stack!]
    [ So the first thing to do is to define a word to drop the TOS]
    [ And then use that to clean up our comments]

    [[a]DEFINE][pop]DEFINE

    [ For brevity we define ';' to be pop ]
    [pop][;]DEFINE

    [ We now have 6 comment-strings on the stack, so drop them];;; ;;;


    [][true] TEST   [ assert the stack is now empty ];

    [ for brevity, we define ':' to be DEFINE ];
    
    [LEAVE DEFINE CREATE ENTER][:]DEFINE


    [ the following 'define' gives us a delayed-lookup ];
   [
       [var]: [value]:
       [[value]?] [var]?:
   ][&]: 

    [ nicer to write '?' rather than 'LOOKUP' ];
    [LOOKUP][?]:
    
    [ now define the words 'true' and 'false' ];
    [[true]][true]:
    [[false]][false]:

    [true false STEQ][eq]:  [ defines equality ];
    [str_eq1][a][a]eq TEST
    [str_eq2][a][b]eq false eq TEST
    
    [ implement dup to copy TOS ];
    [[a]: [a]? [a]?][dup]:

    [dup1][1]dup eq TEST

    [ swap to swap TOS and TOS-1];
    [[a]: [b]: [a]? [b]?][swap]:

    

    [ develop if-statement ];
    [ [boolean]:[false_block]:[true_block]:    [pull off the arguments];
      true boolean [true_block]? [false_block]? STEQ EXECUTE]
    [if]:

    [if1] [[1]][[2]]true  if [1]eq TEST
    [if2] [[1]][[2]]false if [2]eq TEST

    [ instead of writing [] true TEST we write assert_empty ];
    [[assert_empty failed]true TEST][assert_empty]:

    [ we need only implement nand.  Can then derive not,and & or];

    [ nand : only return false when both inputs true ];
    [ [b]: [a]:
        [[false][true]b if]
        [true]
        a 
        if
    ][nand]: 

    [nand1] true  true    nand false eq TEST 
    [nand2] true  false   nand true  eq TEST 
    [nand3] false true    nand true  eq TEST 
    [nand4] false false   nand true  eq TEST 

    [dup nand][not]:

    [not1]false not TEST  
    [not2]true not false eq TEST 

    [ boolean-and : True only when both args are True];

    [nand not][and]:

    [and1] true  true   and true  eq TEST
    [and2] true  false  and false eq TEST
    [and3] false true   and false eq TEST
    [and4] false false  and false eq TEST

    [ boolean-or : True when either arg is true];

    [not swap not nand][or]:

    [or1] true  true   or true  eq TEST
    [or2] true  false  or true eq TEST
    [or3] false true   or true eq TEST
    [or4] false false  or false eq TEST
    
    [implement string reversal recursively];

    [[s]:
        [[]]
        [[s]? CHOP swap reverse JOIN ]
        [s]? [] eq if

    ]
    [reverse]:

    [reverse1] []reverse []eq TEST
    [reverse2] [a]reverse [a]eq TEST
    [reverse3] [abc]reverse [cba]eq TEST 


    [implement zero as an empty string]; 
    [[]][nat_0]:

    [ nat_equals is simply eq : ];
    [eq][nat_eq]:

    [implement a successor function: Add one char to a given string];
    [[*] JOIN][nat_succ]:

    [implement a few numbers for later use];
    [nat_0 nat_succ][nat_1]:
    [nat_1 nat_succ][nat_2]:
    [nat_2 nat_succ][nat_3]:
    [nat_3 nat_succ][nat_4]:
    [nat_4 nat_succ][nat_5]:
    [nat_5 nat_succ][nat_6]:
    [nat_4 nat_succ][nat_5]:

    [addition is easy -- just JOIN two numbers together];
    [JOIN][nat_add]:

    [add1] nat_1 nat_2 nat_add nat_3 eq TEST  [ tests 1+2=3 ];

    [ for subtraction, we're going to need a decrement function nat_dec ];
    [ we need to check the zero case ];

    [ [t]: [[nat_dec called on nat_0] ERROR]
           [[t]? CHOP pop] 
           [t]? nat_0 eq if
    ][nat_dec]:

 
    [ comparing two nats can be done via eq];
    [eq][nat_eq]:

    [ now consider subtraction: we need repeated decrements];
    [ the base case is 'x 0 sub' should be 'x'];
    [ the recursive case is 'x y sub' should be 'x nat_dec y nat_dec];

    [ [y]: [x]:
        [[x]?]
        [[x]? nat_dec [y]? nat_dec nat_sub]
        [y]? nat_0 nat_eq if
    ][nat_sub]:

    [sub1] nat_1 nat_1 nat_sub nat_0 nat_eq TEST
    [sub2] nat_5 nat_3 nat_sub nat_2 nat_eq TEST

    [ want nat_lt and nat_gt ];
    
    [ [y]: [x]:
        [[true][false][y]? nat_0 eq if]
        [[x]? nat_dec [y]? nat_dec nat_gte ]
        [y]? nat_0 eq [x]? nat_0 eq or if
    ][nat_gte]:

    [gte1] nat_1 nat_1 nat_gte TEST
    [gte2] nat_1 nat_0 nat_gte TEST
    [gte3] nat_2 nat_3 nat_gte not TEST

    [ [y]: [x]: 
        [x]? [y]? nat_gte [x]? [y]? nat_eq not and
    ][nat_gt]:

    [gt1] nat_1 nat_0 nat_gt TEST
    [gt2] nat_1 nat_1 nat_gt not TEST
    [gt1] nat_1 nat_2 nat_gt not TEST


    [ nat_gt not ][nat_lte]:

    [lte1] nat_1 nat_0 nat_lte not TEST
    [lte2] nat_1 nat_1 nat_lte TEST
    [lte3] nat_1 nat_2 nat_lte TEST

    [ nat_gte not][nat_lt]:

    [lt1] nat_1 nat_0 nat_lt not TEST
    [lt2] nat_1 nat_1 nat_lt not TEST
    [lt3] nat_1 nat_2 nat_lt TEST

    [[i]:
        [nat_1]
        [[i]? nat_dec fib [i]?nat_dec nat_dec fib nat_add]
        [i]? nat_3 nat_lt if
    ][fib]:

    [ multplication is repeated addition ];
    [ for x*y we have the base case x*0=0 ];
    [ and x*y = x*(y-1) + x ];
    [
        [y]: [x]:
        [nat_0]
        [
            [[x]?]
            [[x]? [y]? nat_dec nat_times [x]? nat_add] 
            [y]? nat_0 eq if
        ]
        [y]? nat_0 eq if
    ][nat_times]:
    
    [nat_times1] nat_1 nat_1 nat_times nat_1 nat_eq TEST
    [nat_times2] nat_2 nat_2 nat_times nat_4 nat_eq TEST
    [nat_times3] nat_3 nat_2 nat_times nat_6 nat_eq TEST


[
    [ a new version of TEST which checks the top two items of the stack];
    [[y]: [x]: [y]? eq [x]? eq and TEST]
    [TEST2]:

    [TEST2] nat_1 nat_2 nat_1 nat_2 TEST2
];

    [ to compute x / y we repeatedly subtract y from x until ];
    [ we can go no further, and report the quotient ];

    [
        [y]: [x]:
        [
            [nat_1]
            [nat_0]
            [x]? [y]? nat_eq if
        ]
        [[x]? [y]? nat_sub [y]? nat_divide nat_1 nat_add]
        [x]? [y]? nat_lte if
    ][nat_divide]:

    [divide1]nat_1 nat_1 nat_divide nat_1 nat_eq TEST
    [divide2]nat_1 nat_2 nat_divide nat_0 nat_eq TEST
    [divide3]nat_3 nat_2 nat_divide nat_1 nat_eq TEST
    [divide4]nat_4 nat_2 nat_divide nat_2 nat_eq TEST

    [
        [y]: [x]:
        [x]? [y]? nat_divide [y]? nat_times [x]? swap nat_sub
    ][nat_remainder]:


    [rem1] nat_1 nat_1 nat_remainder nat_0 nat_eq TEST
    [rem2] nat_1 nat_2 nat_remainder nat_1 nat_eq TEST
    [rem3] nat_3 nat_2 nat_remainder nat_1 nat_eq TEST
    [rem4] nat_2 nat_3 nat_remainder nat_2 nat_eq TEST
    [rem5] nat_6 nat_3 nat_remainder nat_0 nat_eq TEST
    [rem6] nat_6 nat_4 nat_remainder nat_2 nat_eq TEST

    assert_empty
    
