
    
    [ Here is where we bootstrap our little language]
    [ It is clear that this is a comment, and it is polluting the stack!]
    [ So the first thing to do is to define a word to drop the TOS]
    [ And then use that to clean up our comments]

    [[a]DEFINE][pop]DEFINE

    [ For brevity we define ';' to be pop ]
    [pop][;]DEFINE

    [ We now have 6 comment-strings on the stack, so drop them];;; ;;;


    [stack not empty][true] TEST   [ assert the stack is now empty ];

    [ for brevity, we define ':' to be DEFINE ];
    
    [LEAVE DEFINE CREATE ENTER][:]DEFINE



    [ nicer to write '?' rather than 'LOOKUP' ];
    [LOOKUP][?]:
    
    [ now define the words 'true' and 'false' ];
    [[true]][true]:
    [[false]][false]:

    [true false STEQ][eq]:  [ defines equality ];
    [str_eq1][a][a]eq TEST
    [str_eq2][a][b]eq false eq TEST
    
    [ implement dup to copy TOS ];
    [[a]: [a]? [a]?][dup]:

    [dup1][1]dup eq TEST

    [ swap to swap TOS and TOS-1];
    [[a]: [b]: [a]? [b]?][swap]:

    

    [ develop if-statement ];
    [ [boolean]:[false_block]:[true_block]:    [pull off the arguments];
      true boolean [true_block]? [false_block]? STEQ EXECUTE]
    [if]:

    [if1] [[1]][[2]]true  if [1]eq TEST
    [if2] [[1]][[2]]false if [2]eq TEST


    [ we need only implement nand.  Can then derive not,and & or];

    [ nand : only return false when both inputs true ];
    [ [b]: [a]:
        [[false][true]b if]
        [true]
        a 
        if
    ][nand]: 

    [nand1] true  true    nand false eq TEST 
    [nand2] true  false   nand true  eq TEST 
    [nand3] false true    nand true  eq TEST 
    [nand4] false false   nand true  eq TEST 

    [dup nand][not]:

    [not1]false not TEST  
    [not2]true not false eq TEST 

    [ boolean-and : True only when both args are True];

    [nand not][and]:

    [and1] true  true   and true  eq TEST
    [and2] true  false  and false eq TEST
    [and3] false true   and false eq TEST
    [and4] false false  and false eq TEST

    [ boolean-or : True when either arg is true];

    [not swap not nand][or]:

    [or1] true  true   or true  eq TEST
    [or2] true  false  or true eq TEST
    [or3] false true   or true eq TEST
    [or4] false false  or false eq TEST
    
    [implement string reversal recursively];

    [[s]:
        [[]]
        [[s]? CHOP swap reverse JOIN ]
        [s]? [] eq if

    ]
    [reverse]:

    [reverse1] []reverse []eq TEST
    [reverse2] [a]reverse [a]eq TEST
    [reverse3] [abc]reverse [cba]eq TEST 


    [implement zero as an empty string]; 
    [[]][nat_0]:

    [ nat_equals is simply eq : ];
    [eq][nat_eq]:

    [nat_0_equals] nat_0 nat_0 nat_eq TEST

    [implement a successor function: Add one char to a given string];
    [[*] JOIN][nat_succ]:

    [ show that nat_0 and nat_0 nat_succ are different];
    [nat_succ1] nat_0 nat_succ nat_0 eq not TEST

    [implement a few numbers for later use];
    [nat_0 nat_succ][nat_1]:
    [nat_1 nat_succ][nat_2]:
    [nat_2 nat_succ][nat_3]:
    [nat_3 nat_succ][nat_4]:
    [nat_4 nat_succ][nat_5]:
    [nat_5 nat_succ][nat_6]:

    [addition is easy -- just JOIN two numbers together];
    [JOIN][nat_add]:

    [add1] nat_1 nat_2 nat_add nat_3 eq TEST  [ tests 1+2=3 ];

    [ for subtraction, we're going to need a decrement function nat_dec ];
    [ we need to check the zero case ];

    [ [t]: [[nat_dec called on nat_0] ERROR]
           [[t]? CHOP pop] 
           [t]? nat_0 nat_eq if
    ][nat_dec]:

    [nat_dec1] nat_1 nat_dec nat_0 nat_eq TEST

 

    [ now consider subtraction: we need repeated decrements];
    [ the base case is 'x 0 sub' should be 'x'];
    [ the inductive case is 'x y sub' should be 'x nat_dec y nat_dec];

    [ [y]: [x]:
        [[x]?]
        [[x]? nat_dec [y]? nat_dec nat_sub]
        [y]? nat_0 nat_eq if
    ][nat_sub]:

    [sub1] nat_1 nat_1 nat_sub nat_0 nat_eq TEST
    [sub2] nat_5 nat_3 nat_sub nat_2 nat_eq TEST

    [ want nat_lt and nat_gt etc.];
    
    [ [y]: [x]:
        [[true][false][y]? nat_0 eq if]
        [[x]? nat_dec [y]? nat_dec nat_gte ]
        [y]? nat_0 eq [x]? nat_0 eq or if
    ][nat_gte]:

    [gte1] nat_1 nat_1 nat_gte TEST
    [gte2] nat_1 nat_0 nat_gte TEST
    [gte3] nat_2 nat_3 nat_gte not TEST

    [ [y]: [x]: 
        [x]? [y]? nat_gte [x]? [y]? nat_eq not and
    ][nat_gt]:

    [gt1] nat_1 nat_0 nat_gt TEST
    [gt2] nat_1 nat_1 nat_gt not TEST
    [gt1] nat_1 nat_2 nat_gt not TEST


    [ nat_gt not ][nat_lte]:

    [lte1] nat_1 nat_0 nat_lte not TEST
    [lte2] nat_1 nat_1 nat_lte TEST
    [lte3] nat_1 nat_2 nat_lte TEST

    [ nat_gte not][nat_lt]:

    [lt1] nat_1 nat_0 nat_lt not TEST
    [lt2] nat_1 nat_1 nat_lt not TEST
    [lt3] nat_1 nat_2 nat_lt TEST

    [[i]:
        [nat_1]
        [[i]? nat_dec fib [i]?nat_dec nat_dec fib nat_add]
        [i]? nat_3 nat_lt if
    ][fib]:

    [fib1] nat_1 fib nat_1 nat_eq TEST
    [fib2] nat_2 fib nat_1 nat_eq TEST
    [fib4] nat_4 fib nat_3 nat_eq TEST

    [ multplication is repeated addition ];
    [ for x*y we have the base case x*0=0 ];
    [ and x*y = x*(y-1) + x ];
    [
        [y]: [x]:
        [nat_0]
        [
            [[x]?]
            [[x]? [y]? nat_dec nat_times [x]? nat_add] 
            [y]? nat_0 eq if
        ]
        [y]? nat_0 eq if
    ][nat_times]:
    
    [nat_times1] nat_1 nat_1 nat_times nat_1 nat_eq TEST
    [nat_times2] nat_2 nat_2 nat_times nat_4 nat_eq TEST
    [nat_times3] nat_3 nat_2 nat_times nat_6 nat_eq TEST


[
    [ a new version of TEST which checks the top two items of the stack];
    [[y]: [x]: [y]? eq [x]? eq and TEST]
    [TEST2]:

    [TEST2] nat_1 nat_2 nat_1 nat_2 TEST2
];

    [ to compute x / y we repeatedly subtract y from x until ];
    [ we can go no further, and report the quotient ];

    [
        [y]: [x]:
        [
            [nat_1]
            [nat_0]
            [x]? [y]? nat_eq if
        ]
        [[x]? [y]? nat_sub [y]? nat_divide nat_1 nat_add]
        [x]? [y]? nat_lte if
    ][nat_divide]:

    [divide1]nat_1 nat_1 nat_divide nat_1 nat_eq TEST
    [divide2]nat_1 nat_2 nat_divide nat_0 nat_eq TEST
    [divide3]nat_3 nat_2 nat_divide nat_1 nat_eq TEST
    [divide4]nat_4 nat_2 nat_divide nat_2 nat_eq TEST

    [
        [y]: [x]:
        [x]? [y]? nat_divide [y]? nat_times [x]? swap nat_sub
    ][nat_remainder]:


    [rem1] nat_1 nat_1 nat_remainder nat_0 nat_eq TEST
    [rem2] nat_1 nat_2 nat_remainder nat_1 nat_eq TEST
    [rem3] nat_3 nat_2 nat_remainder nat_1 nat_eq TEST
    [rem4] nat_2 nat_3 nat_remainder nat_2 nat_eq TEST
    [rem5] nat_6 nat_3 nat_remainder nat_0 nat_eq TEST
    [rem6] nat_6 nat_4 nat_remainder nat_2 nat_eq TEST


    [ a simple pair object ];

    [ [second]: [first]:
      CREATE [obj]: obj ENTER [first]? [first]: [second]? [second]:
      obj LEAVE 
    ][pair_make]:


    [ENTER [first]? LEAVE] [pair_first]:

    [ENTER [second]? LEAVE] [pair_second]:


    [pair1][1][2]pair_make pair_first [1] eq TEST
    [pair2][1][2]pair_make pair_second [2] eq TEST


    [ a linked-list ];

    [[][]pair_make][linked_list_end]:
    [[link]: link pair_first [] eq link pair_second [] eq and] 
    [linked_list_is_end]:

    [linked_list_end1]linked_list_end linked_list_is_end TEST 
 
    [ construct a link: link body link_make ];

    [pair_make][link_make]:
    [pair_second][link_object]:
    [pair_first][link_link]:
    [[link_link linked_list_is_end][link_is_end]:];

    [link_make1] linked_list_end [a] link_make link_object [a] eq TEST
    [link_make2] linked_list_end [a] link_make link_link linked_list_is_end TEST
    [link_make3] linked_list_end [a] link_make linked_list_is_end not TEST


[ now define list object in terms of linked lists : ];
    [linked_list_end][list_new]:  
    [link_make][list_add]:
    [linked_list_is_end][list_is_empty]:
    [link_object][list_object]:
    [link_link][list_next]:
   
    [list_new] list_new list_is_empty TEST
    [list_add] list_new [a] list_add list_object [a] eq TEST
    [list_add2] list_new [a] list_add list_is_empty false eq TEST  

    [list_add3] list_new [a] list_add [b] list_add list_next list_object [a] eq
    TEST

[ we might like to pop an item off a list, resulting in a new list and the
object];


    [[list]:
        [[cannot pop empty list]ERROR]
        [list list_next list list_object]
        list list_is_empty if
    ][list_pop]:

   [list_pop1] list_new [a] list_add list_pop swap pop [a] eq TEST
   [list_pop2] list_new [a] list_add list_pop pop list_is_empty TEST
   
[ finally we want to be able to check if a list contains an item];

    [[object]: [list]:
        [false]
        [ [true]
          [list list_next [object]? list_contains]
          list list_object [object]? eq if
        ]
        list list_is_empty if
    ][list_contains]:

   [list_contains1] list_new [a] list_contains not TEST
   [list_contains2] list_new [a] list_add [a] list_contains TEST
   [list_contains3] list_new [a] list_add [b] list_contains not TEST

[
    [list]:
        [nat_0]
        [list list_next list_length nat_1 nat_add]
        list list_is_empty if
]
[list_length]:

[list_length_zero] list_new list_length nat_0 nat_eq TEST
[list_length_one] list_new [x] list_add list_length nat_1 nat_eq TEST

[ define booleans more formally ];

[true][bool_t]:
[false][bool_f]:
[not][bool_not]:
[nand][bool_nand]:
[and][bool_and]:
[or][bool_or]:
[eq][bool_eq]:

[ given a block with the variable [x], evaluate it over {true,false}
  and answer the "anded" result
  ];

[ first we do it explicitly for true and false];

[[block]: CREATE ENTER true [x]: block LEAVE ][eval_x_true]:
[[block]: CREATE ENTER false [x]: block LEAVE ][eval_x_false]:

[block_eval1] [x] eval_x_true TEST
[block_eval2] [x] eval_x_false not TEST

[[block]: [block]? eval_x_true [block]? eval_x_false bool_and][eval_x]:

[block_eval3] [x] eval_x bool_f bool_eq TEST


[tautology] [x bool_not x bool_nand] eval_x TEST

[[bool]: [block]: CREATE ENTER bool [x]: block LEAVE][eval_x_arg]:

[true eval_x_arg][eval_x_true_factored]:
[false eval_x_arg][eval_x_false_factored]:

[[block]: [block]? eval_x_true_factored [block]? eval_x_false_factored
    bool_and][eval_x_factored]:

[[block]: [var]: 
    CREATE ENTER bool_t  [var]?   : CREATE ENTER block LEAVE LEAVE
    CREATE ENTER bool_f  [var]?   : CREATE ENTER block LEAVE LEAVE
    bool_and]
[eval]:

[
    [dec]: [list]:        
        [list]
        [
            [dec]? CHOP [char]: [dec]:
                [list [dec]? get_declaration_list_iter]
                [list [char]? list_add [dec]? get_declaration_list_iter]
                [char]? [ ] eq if       
        ]
        [dec]? [] eq if
]
[get_declaration_list_iter]:



[list_new swap get_declaration_list_iter][get_declaration_list]:


[empty_declaration] [] get_declaration_list list_is_empty TEST
[ignore_leading_spaces] [   ] get_declaration_list list_is_empty TEST
[single  ] [a] get_declaration_list [a] list_contains TEST
[double ] [a b] get_declaration_list [b] list_contains TEST
[three] [ a  b c ] get_declaration_list list_length nat_3 nat_eq TEST

[
    [block]: [vars]:
        [vars]? get_declaration_list [block]? bool_eval_iter
]
[bool_eval]:

[
    [block]: [vlist]:
        [block]
        [
            vlist list_pop [var]: [vlist]:
            CREATE ENTER bool_t [var]? : vlist [block]? bool_eval_iter LEAVE 
            CREATE ENTER bool_f [var]? : vlist [block]? bool_eval_iter LEAVE
            bool_and
        ]
        vlist list_is_empty if
]
[bool_eval_iter]:

[bool_eval no vars]   []     [bool_t]            bool_eval TEST
[bool_eval x only]    [x]    [x not x bool_nand] bool_eval TEST
[bool_eval x fails]   [x]    [x]                 bool_eval not TEST
[bool_eval x y]       [x y]  [bool_t]            bool_eval TEST
[bool_eval x y fail]  [x y]  [x y nand]          bool_eval not TEST
[bool_eval x unbound] [[]     [x]   bool_eval] ASSERT not TEST

[ we now want to work with specific "objects" ];

[ define "objects" ];

[pair_make][object_make]:
[pair_first][object_type]:
[pair_second][object_body]:

[ we want types to be objects themselves...];

[[*] [*] object_make] [root_type_make]:

[object_make][type_make]: 
[object_type][type_super]:
[object_body][type_name]:

[ all subsequent types descend from root_type ];

[super type of root_type is "*"] root_type_make type_super [*] eq TEST

[st1] root_type_make [foo] type_make type_super object_type [*] eq TEST
[st2] root_type_make [foo] type_make type_super type_super  [*] eq TEST

[ define a type directly inherited from root_type];
[root_type_make swap type_make ][make_simple_type]:


[ define the type "proposition" ];

[root_type_make [proposition] type_make swap object_make][proposition_make]:
[object_body][proposition_label]:

[test prop type  ] [P] proposition_make object_type type_name [proposition] eq TEST
[test prop label ] [P] proposition_make proposition_label [P] eq TEST

[ define the abstract type of "form" ];

[root_type_make [form] type_make][form_type_make]:

[ define the three sub-types of form_prop, form_neg and form_imp ];

[form_type_make [form_prop] type_make swap object_make][form_prop_make]:
[object_body][form_prop_prop]:

[test form_prop type] [P] proposition_make form_prop_make object_type
type_name [form_prop] eq TEST



[ test form_prop prop]
    [P] proposition_make form_prop_make form_prop_prop proposition_label
    [P] eq TEST



[form_type_make [form_neg] type_make swap object_make][form_neg_make]:
[object_body][form_neg_prop]:



[ pair_make form_type_make [form_imp] type_make swap object_make][form_imp_make]:
[object_body pair_first][form_imp_ante]:
[object_body pair_second][form_imp_cons]:

[form_imp type][P]proposition_make [Q] proposition_make form_imp_make
    object_type type_name [form_imp] eq TEST

[form_imp ante][P]proposition_make [Q] proposition_make form_imp_make
    form_imp_ante proposition_label [P] eq TEST


[form_imp cons][P]proposition_make [Q] proposition_make form_imp_make
    form_imp_cons proposition_label [Q] eq TEST


